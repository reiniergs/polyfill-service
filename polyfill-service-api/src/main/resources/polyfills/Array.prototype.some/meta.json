{"aliases":["default-3.3","default-3.4","default-3.5","default-3.6","default","es5","modernizr:es5array","blissfuljs"],"browsers":{"ie":"6 - 8"},"spec":"http://people.mozilla.org/~jorendorff/es6-draft.html#sec-array.prototype.some","docs":"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/some","detectSource":"'some' in Array.prototype","testSource":"","baseDir":"Array/prototype/some","hasTests":true,"testsSource":"/* eslint-env mocha, browser*/\n/* global proclaim, it */\n\n// See: https://people.mozilla.org/~jorendorff/es6-draft.html#sec-array.prototype.some\n\nbeforeEach(function() {\n\tthis.array = [0, 2, 4, 6, 8, 10, 12, 14];\n});\n\nit(\"Should not accept a function argument that is not callable\", function() {\n\tvar array = this.array;\n\tproclaim.throws(function() { array.some({}); }, TypeError);\n});\n\nit(\"Should accept a function with three parameters: the value of the element, the index of the element and the object being traversed\", function() {\n\tvar array = this.array;\n\n\tarray.some(function(value, index, object) {\n\t\tproclaim.strictEqual(object, array);\n\t\tproclaim.equal(object[index], value);\n\t\treturn false;\n\t});\n});\n\nit(\"Should accept an optional 'this' argument as its second argument which becomes the 'this' value for the function argument\", function() {\n\tvar mockThis = { foo: \"bar\" };\n\tvar array = this.array;\n\n\tarray.some(function(value) {\n\t\tproclaim.strictEqual(this, mockThis);\n\t\tproclaim.equal(this.foo, mockThis.foo);\n\t\treturn false;\n\t}, mockThis);\n});\n\nit(\"Should pass a reference to the array as the third parameter to the function argument\", function() {\n\tvar array = [10];\n\n\tarray.some(function(value, index, object) {\n\t\tobject[0] = 100;\n\t\treturn false;\n\t});\n\n\tproclaim.equal(array[0], 100);\n});\n\nit(\"Should not iterate over elements appended to the array after the call to some.  The range is fixed before the first call to the callback\", function() {\n\tvar array = [1, 2, 3, 4, 5, 6];\n\tvar visited = [];\n\n\tarray.some(function(value, index, object) {\n\t\tarray.push(index);\n\t\tvisited[index] = value;\n\t\treturn false;\n\t});\n\n\tproclaim.deepEqual(visited, [1, 2, 3, 4, 5, 6]);\n\n\t// Expect the original array to be the same for the first 6 elements, with\n\t// the additional 0, 1, .. 5 appended (the indices of the first 6 elements\n\t// in the range covered by some at the start of its invocation\n\tproclaim.deepEqual(array, [1, 2, 3, 4, 5, 6, 0, 1, 2, 3, 4, 5]);\n});\n\nit(\"Should return false if the array is empty\", function() {\n\tvar a = [];\n\tproclaim.equal(a.some(function(value) { return true; }), false);\n});\n\nit(\"Should not visit elements that are deleted after the call to some begins and before being visited\", function() {\n\tvar a = [1, 2, 3, 4, 5, 6];\n\tvar visited = [];\n\n\ta.some(function(value, index, object) {\n\t\tdelete object[5];\n\t\tvisited.push(index);\n\t\treturn false;\n\t});\n\n\t// Should only visit the first 5 indices\n\tproclaim.deepEqual(visited, [0, 1, 2, 3, 4]);\n});\n\nit(\"Should return true as soon as the callback returns true\", function() {\n\tvar a = [0, 1, 2, 3, 4];\n\tvar visited = [];\n\tproclaim.equal(a.some(function(value) {\n\t\tvisited.push(value);\n\t\treturn value > 2;\n\t}), true);\n\n\tproclaim.deepEqual(visited, [0, 1, 2, 3]);\n});\n\nit(\"Should return false if the callback never returns true\", function() {\n\tvar a = [0, 1, 2, 3, 4];\n\tvar visited = [];\n\tproclaim.equal(a.some(function(value) {\n\t\tvisited.push(value);\n\t\treturn false;\n\t}), false);\n\n\tproclaim.deepEqual(visited, a);\n});"}