{"aliases":["es6","modernizr:es6array","blissfuljs","default-3.4","default-3.5","default-3.6","default"],"browsers":{"chrome":"<45","firefox":"4 - 31","ie":"6 - 11","ie_mob":"10 - *","opera":"*","op_mini":"*","safari":"<9","firefox_mob":"<32","android":"*","ios_saf":"<9","samsung_mob":"<5","bb":"10 - *"},"dependencies":["Object.defineProperty"],"spec":"http://people.mozilla.org/~jorendorff/es6-draft.html#sec-array.from","docs":"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from","detectSource":"'from' in Array && (function () {\n\ttry {\n\t\tArray.from({ length: -Infinity });\n\n\t\treturn true;\n\t} catch (e) {\n\t\treturn false;\n\t}\n})()","testSource":"","baseDir":"Array/from","hasTests":true,"testsSource":"/* eslint-env mocha, browser */\n/* global proclaim */\n\nit('has correct instance', function () {\n\tproclaim.isInstanceOf(Array.from, Function);\n});\n\nit('has correct name', function () {\n\tfunction nameOf(fn) {\n\t\treturn Function.prototype.toString.call(fn).match(/function\\s*([^\\s]*)\\(/)[1];\n\t}\n\tproclaim.equal(nameOf(Array.from), 'from');\n});\n\nit('has correct argument length', function () {\n\tproclaim.equal(Array.from.length, 1);\n});\n\ndescribe('returns an array with', function () {\n\tit('arrays', function () {\n\t\tproclaim.deepEqual(Array.from([]), []);\n\t\tproclaim.deepEqual(Array.from(['a', 'b', 'c']), ['a', 'b', 'c']);\n\t});\n\n\tit('fills holes in arrays', function () {\n\t\tvar arr = [1, 2, 3];\n\t\tdelete arr[1];\n\t\t/**\n\t\t * These are unrolled as expect.js' eql doesn't work on\n\t\t * arrays created with undefined elements.\n\t\t * https://github.com/Automattic/expect.js/issues/140\n\t\t */\n\t\tproclaim.deepEqual(Array.from(arr)[0], 1);\n\t\tproclaim.deepEqual(Array.from(arr)[1], undefined);\n\t\tproclaim.deepEqual(Array.from(arr)[2], 3);\n\t\t/* eslint-disable no-sparse-arrays */\n\t\tproclaim.deepEqual(Array.from([4, , 6])[1], undefined);\n\t});\n\n\tit('objects', function () {\n\t\tproclaim.deepEqual(Array.from({}), []);\n\t\tproclaim.deepEqual(Array.from({ 0: 'a' }), []);\n\t\tproclaim.deepEqual(Array.from({ 0: 'a', 1: 'b', 2: 'c', length: 3 }), ['a', 'b', 'c']);\n\t});\n\n\tit('Iterable', function () {\n\t\tvar set;\n\t\tvar setIterator;\n\t\tvar map;\n\t\tvar mapIterator;\n\n\t\tif ('Map' in window && 'entries' in Map.prototype) {\n\n\t\t\tmap = new Map();\n\t\t\tmap.set(1,2);\n\t\t\tmap.set(3,4);\n\t\t\tmapIterator = map.values();\n\n\t\t\tif (typeof mapIterator.next === 'function') {\n\n\t\t\t\t// Test map iterable\n\t\t\t\tproclaim.deepEqual(Array.from(mapIterator), [2,4]);\n\n\t\t\t\tit('can convert from Map', function () {\n\t\t\t\t\tproclaim.deepEqual(Array.from(map), [[1,2],[3,4]]);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tif ('Set' in window && 'values' in Set.prototype) {\n\n\t\t\tset = new Set();\n\t\t\tset.add(1);\n\t\t\tset.add(2);\n\t\t\tset.add(3);\n\t\t\tset.add(4);\n\t\t\tsetIterator = set.values();\n\n\t\t\tif (typeof setIterator.next === 'function') {\n\n\t\t\t\t// Test set iterable\n\t\t\t\tproclaim.deepEqual(Array.from(setIterator), [1,2,3,4]);\n\n\t\t\t\tit('can convert from Set', function () {\n\t\t\t\t\tproclaim.deepEqual(Array.from(set), [1,2,3,4]);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tit('can convert from a user-defined iterator', function () {\n\t\t\tfunction iterator(cnt) {\n\t\t\t\treturn {\n\t\t\t\t\tnext: function () {\n\t\t\t\t\t\treturn cnt === 0\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tdone: true\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\tvalue: cnt--,\n\t\t\t\t\t\t\t\tdone: false\n\t\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t\tproclaim.deepEqual(Array.from(iterator(0)), []);\n\t\t\tproclaim.deepEqual(Array.from(iterator(1)), [1]);\n\t\t\tproclaim.deepEqual(Array.from(iterator(2)), [2, 1]);\n\t\t\tproclaim.deepEqual(Array.from(iterator(3)), [3, 2, 1]);\n\t\t});\n\n\t});\n\n\tit('strings', function () {\n\t\tproclaim.deepEqual(Array.from(''), []);\n\t\tproclaim.deepEqual(Array.from('abc'), ['a', 'b', 'c']);\n\t});\n\n\tit('numbers', function () {\n\t\tproclaim.deepEqual(Array.from(-Infinity), []);\n\t\tproclaim.deepEqual(Array.from(-3), []);\n\t\tproclaim.deepEqual(Array.from(-0), []);\n\t\tproclaim.deepEqual(Array.from(0), []);\n\t\tproclaim.deepEqual(Array.from(3), []);\n\t\t// REMOVAL: it may take a rediculous amount of time to calculate this\n\t\t// proclaim.deepEqual(Array.from(Infinity), []);\n\t});\n\n\tit('regular expressions', function () {\n\t\tproclaim.deepEqual(Array.from(/abc/), []);\n\t});\n\n\tit('objects with in-range lengths', function () {\n\t\tproclaim.equal(Array.from({ length: 0 }).length, 0);\n\t\tproclaim.equal(Array.from({ length: 3 }).length, 3);\n\t\t/**\n\t\t * These are unrolled as expect.js' eql doesn't work on\n\t\t * arrays created with undefined elements.\n\t\t * https://github.com/Automattic/expect.js/issues/140\n\t\t */\n\t\tproclaim.equal(Array.from({ length: 3 })[0], undefined);\n\t\tproclaim.equal(Array.from({ length: 3 })[1], undefined);\n\t\tproclaim.equal(Array.from({ length: 3 })[2], undefined);\n\t\tproclaim.equal(Array.from({ length: '+3' }).length, 3);\n\t\t// proclaim.equal(Array.from({ length: Infinity }).length, undefined);\n\t});\n\n\tit('objects with out-of-range lengths', function () {\n\t\tproclaim.equal(Array.from({ length: -0 }).length, 0);\n\t\tproclaim.equal(Array.from({ length: -3 }).length, 0);\n\t\tproclaim.equal(Array.from({ length: '-3' }).length, 0);\n\t\tproclaim.equal(Array.from({ length: -Infinity }).length, 0);\n\t});\n\n\tit('mapping functions', function () {\n\t\tfunction addElementAndIndex(element, index) {\n\t\t\treturn element + index;\n\t\t}\n\n\t\tproclaim.deepEqual(Array.from(['a', 'b', 'c'], addElementAndIndex), ['a0', 'b1', 'c2']);\n\t\tproclaim.deepEqual(Array.from({ 0: 'a', 1: 'b', 3: 'c' }, addElementAndIndex), []);\n\t\tproclaim.deepEqual(Array.from({ 0: 'a', 1: 'b', 2: 'c', length: 3 }, addElementAndIndex), ['a0', 'b1', 'c2']);\n\t\tproclaim.deepEqual(Array.from('abc', addElementAndIndex), ['a0', 'b1', 'c2']);\n\n\t\tArray.from(['a', 'b', 'c'], function () {\n\t\t\tproclaim.equal(arguments.length, 2);\n\t\t});\n\t});\n\n\tit('this as an object', function () {\n\t\tvar context = {};\n\n\t\tArray.from(['a', 'b', 'c'], function (value, index) {\n\t\t\tproclaim.isInstanceOf(this, Object);\n\t\t\tproclaim.strictEqual(this.valueOf(), context);\n\t\t}, context);\n\t});\n\n\tit('this as 42', function () {\n\t\tvar context = 42;\n\n\t\tArray.from(['a', 'b', 'c'], function (value, index) {\n\t\t\tproclaim.isInstanceOf(this, Number);\n\t\t\tproclaim.strictEqual(this.valueOf(), 42);\n\t\t}, context);\n\t});\n\n\tit('this as false', function () {\n\t\tvar context = false;\n\n\t\tArray.from(['a', 'b', 'c'], function (value, index) {\n\t\t\tproclaim.isInstanceOf(this, Boolean);\n\t\t\tproclaim.strictEqual(this.valueOf(), false);\n\t\t}, context);\n\t});\n});\n\ndescribe('throws', function () {\n\tit('non-iterable objects', function () {\n\t\tproclaim.throws(function () {\n\t\t\tArray.from();\n\t\t});\n\n\t\tproclaim.throws(function () {\n\t\t\tArray.from(undefined);\n\t\t});\n\n\t\tproclaim.throws(function () {\n\t\t\tArray.from(null);\n\t\t});\n\t});\n\n\tit('specified, invalid mapping functions', function () {\n\t\tproclaim.throws(function () {\n\t\t\tArray.from([1, 2, 3], null);\n\t\t});\n\n\t\tproclaim.throws(function () {\n\t\t\tArray.from([1, 2, 3], /\\*/);\n\t\t});\n\n\t\tproclaim.throws(function () {\n\t\t\tArray.from([1, 2, 3], '');\n\t\t});\n\n\t\tproclaim.throws(function () {\n\t\t\tArray.from([1, 2, 3], []);\n\t\t});\n\n\t\tproclaim.throws(function () {\n\t\t\tArray.from([1, 2, 3], {});\n\t\t});\n\n\t\tproclaim.throws(function () {\n\t\t\tArray.from([1, 2, 3], 3);\n\t\t});\n\t});\n});"}