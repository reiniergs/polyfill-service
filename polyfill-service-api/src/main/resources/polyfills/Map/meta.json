{"aliases":["es6","default-3.6","default"],"browsers":{"ie":"<12","safari":"<9","firefox":"<29","chrome":"<38","android":"<5.1","firefox_mob":"<29","ie_mob":"*","opera_mob":"*","ios_saf":"<9","bb":"10 - *"},"dependencies":["Array.prototype.indexOf","Symbol","Symbol.iterator","Symbol.species","Object.defineProperty","Number.isNaN"],"notes":["For compatibility with very old engines, `Map.prototype.delete` must be accessed using square bracket notation because 'delete' is a reserved word. `myMap.delete()` is an error in IE8. Use `myMap['delete']()` instead.","The test suite for this polyfill is derived from work of Andrea Giammarchi which is [published under an MIT licence](https://github.com/WebReflection/es6-collections)"],"detectSource":"'Map' in this && (function() {\n\ttry {\n\t\treturn (new Map([[1,1], [2,2]])).size === 2;\n\t} catch (e) {\n\t\treturn false;\n\t}\n}())","testSource":"","baseDir":"Map","hasTests":true,"testsSource":"/* eslint-env mocha, browser*/\n/* global proclaim, it */\n\nvar o, generic, callback;\n\nbeforeEach(function() {\n\tif ('Map' in window) o = new Map();\n\tgeneric = {};\n\tcallback = function () {};\n});\n\nit(\"has valid constructor\", function () {\n\tproclaim.isInstanceOf(new Map, Map);\n\tproclaim.isInstanceOf(new Map(), Map);\n\tif (\"__proto__\" in {}) {\n\t\tproclaim.equal((new Map).__proto__.isPrototypeOf(new Map()), true);\n\t\tproclaim.equal((new Map).__proto__ === Map.prototype, true);\n\t}\n});\n\nit (\"can be pre-populated\", function() {\n\tvar a = 1;\n\tvar b = {};\n\tvar c = new Map();\n\tvar m = new Map([[1,1], [b,2], [c, 3]]);\n\tproclaim.equal(m.has(a), true);\n\tproclaim.equal(m.has(b), true);\n\tproclaim.equal(m.has(c), true);\n\tproclaim.equal(m.size, 3);\n});\n\nit(\"implements .size()\", function () {\n\tproclaim.equal(o.size, 0);\n\to.set(\"a\", \"a\");\n\tproclaim.equal(o.size, 1);\n\to[\"delete\"](\"a\"); // Use square-bracket syntax to avoid a reserved word in old browsers\n\tproclaim.equal(o.size, 0);\n});\n\nit(\"implements .has()\", function () {\n\tproclaim.equal(o.has(callback), false);\n\to.set(callback, generic);\n\tproclaim.equal(o.has(callback), true);\n});\n\nit(\"implements .get()\", function () {\n\to.set(callback, generic);\n\tproclaim.equal(o.get(callback, 123), generic);\n\tproclaim.equal(o.get(callback), generic);\n});\n\nit(\"implements .set()\", function () {\n\to.set(callback, generic);\n\tproclaim.equal(o.get(callback), generic);\n\to.set(callback, callback);\n\tproclaim.equal(o.get(callback), callback);\n\to.set(callback, o);\n\tproclaim.equal(o.get(callback), o);\n\to.set(o, callback);\n\tproclaim.equal(o.get(o), callback);\n\to.set(NaN, generic);\n\tproclaim.ok(o.has(NaN));\n\tproclaim.equal(o.get(NaN), generic);\n\to.set(\"key\", undefined);\n\tproclaim.ok(o.has(\"key\"));\n\tproclaim.equal(o.get(\"key\"), undefined);\n\n\tproclaim.ok(!o.has(-0));\n\tproclaim.ok(!o.has(0));\n\to.set(-0, callback);\n\tproclaim.ok(o.has(-0));\n\tproclaim.ok(o.has(0));\n\tproclaim.equal(o.get(-0), callback);\n\tproclaim.equal(o.get(0), callback); // Native impl fails in IE11\n\to.set(0, generic);\n\tproclaim.ok(o.has(-0));\n\tproclaim.ok(o.has(0));\n\tproclaim.equal(o.get(-0), generic);\n\tproclaim.equal(o.get(0), generic);\n});\n\nit(\"implements .delete()\", function () {\n\to.set(callback, generic);\n\to.set(generic, callback);\n\to.set(o, callback);\n\tproclaim.equal(o.has(callback) && o.has(generic) && o.has(o), true);\n\to[\"delete\"](callback);\n\to[\"delete\"](generic);\n\to[\"delete\"](o);\n\tproclaim.equal(!o.has(callback) && !o.has(generic) && !o.has(o), true);\n\tproclaim.ok(o[\"delete\"](o) === false);\n\to.set(o, callback);\n\tproclaim.ok(o[\"delete\"](o));\n});\n\nit(\"does not throw an error when a non-object key is used\", function () {\n\tproclaim.doesNotThrow(function() {\n\t\to.set(\"key\", o);\n\t});\n});\n\nit(\"exhibits correct iterator behaviour\", function () {\n\t// test that things get returned in insertion order as per the specs\n\to = new Map([[\"1\", 1], [\"2\", 2], [\"3\", 3]]);\n\tvar keys = o.keys();\n\tvar values = o.values();\n\tvar k = keys.next()\n\tvar v = values.next();\n\tproclaim.equal(k.value, \"1\");\n\tproclaim.equal(v.value, 1);\n\to['delete'](\"2\");\n\tk = keys.next();\n\tv = values.next();\n\tproclaim.equal(k.value, \"3\");\n\tproclaim.equal(v.value, 3);\n\t// insertion of previously-removed item goes to the end\n\to.set(\"2\", 2);\n\tk = keys.next()\n\tv = values.next();\n\tproclaim.equal(k.value, \"2\");\n\tproclaim.equal(v.value, 2);\n\t// when called again, new iterator starts from beginning\n\tvar entriesagain = o.entries();\n\tproclaim.equal(entriesagain.next().value[0], \"1\");\n\tproclaim.equal(entriesagain.next().value[0], \"3\");\n\tproclaim.equal(entriesagain.next().value[0], \"2\");\n\t// after a iterator is finished, don't return any more elements\n\tk = keys.next();\n\tv = values.next();\n\tproclaim.equal(k.done, true);\n\tproclaim.equal(v.done, true);\n\tk = keys.next();\n\tv = values.next();\n\tproclaim.equal(k.done, true);\n\tproclaim.equal(v.done, true);\n\to.set(\"4\", 4);\n\tk = keys.next();\n\tv = values.next();\n\tproclaim.equal(k.done, true);\n\tproclaim.equal(v.done, true);\n\t// new element shows up in iterators that didn't yet finish\n\tproclaim.equal(entriesagain.next().value[0], \"4\");\n\tproclaim.equal(entriesagain.next().done, true);\n\t// value is present but undefined when done is true, so that Array.from and other noncompliant\n\t// interfaces recognize it as a valid iterator\n\tvar lastResult = entriesagain.next();\n\tproclaim.equal(lastResult.done, true);\n\tproclaim.ok(lastResult.hasOwnProperty('value'));\n\tproclaim.equal(lastResult.value, void 0);\n});\n\nit(\"implements .forEach()\", function () {\n\tvar o = new Map(), i;\n\to.set(\"key 0\", 0);\n\to.set(\"key 1\", 1);\n\to.forEach(function (value, key, obj) {\n\t\tproclaim.equal(key, \"key \" + value);\n\t\tproclaim.equal(obj, o);\n\t\t// even if dropped, keeps looping\n\t\to[\"delete\"](key);\n\t});\n\tproclaim.equal(o.size, 0);\n});\n\nit(\"supports mutations during forEach loops\", function () {\n\tvar o = new Map([[\"0\", 0], [\"1\", 1], [\"2\", 2]]), seen = [];\n\to.forEach(function (value, key, obj) {\n\t\tseen += ','+value;\n\t\tproclaim.equal(obj, o);\n\t\tproclaim.equal(\"\"+value, key);\n\t\t// mutations work as expected\n\t\tif (value === 1) {\n\t\t\to['delete'](\"0\"); // remove from before current index\n\t\t\to['delete'](\"2\"); // remove from after current index\n\t\t\to.set(\"3\", 3); // insertion\n\t\t} else if (value === 3) {\n\t\t\to.set(\"0\", 0); // insertion at the end\n\t\t}\n\t});\n\tproclaim.equal(seen, \",0,1,3,0\");\n});\n\nit(\"implements .clear()\", function(){\n\tvar o = new Map();\n\to.set(1, '1');\n\to.set(2, '2');\n\to.set(3, '3');\n\to.clear();\n\tproclaim.equal(o.size, 0);\n});"}