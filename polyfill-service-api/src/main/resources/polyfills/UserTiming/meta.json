{"browsers":{"android":"<=4","chrome":"<=24","firefox":"<=37","firefox_mob":"*","ie":"6 - 9","ie_mob":"<=9","ios_chr":"*","ios_saf":"*","op_mob":"*","opera":"<=12","safari":"*"},"spec":"http://www.w3.org/TR/user-timing/","license":"MIT","repo":"https://github.com/nicjansma/usertiming.js","docs":"https://developer.mozilla.org/en-US/docs/Web/API/User_Timing_API","install":{"module":"usertiming"},"detectSource":"'performance' in this && typeof this.performance.getEntriesByType === 'function' && typeof this.performance.mark === 'function'","testSource":"","baseDir":"UserTiming","hasTests":true,"testsSource":"/* eslint-env mocha, browser*/\n/* global proclaim, it */\n\nvar perf = window.performance;\n\ndescribe(\"mark()\", function() {\n    beforeEach(function() {\n        perf.clearMarks();\n        perf.clearMeasures();\n    });\n\n    it(\"should handle a simple mark\", function() {\n        perf.mark(\"foo\");\n\n        var entries = perf.getEntriesByType(\"mark\");\n\n        proclaim.equal(entries.length, 1);\n        proclaim.equal(entries[0].name, \"foo\");\n        proclaim.greaterThan(entries[0].startTime, 0);\n    });\n\n    it(\"should throw an exception when a null argument is given\", function() {\n        proclaim.throws(perf.mark);\n    });\n\n    it(\"should throw an exception when passing in a NavigationTiming mark\", function() {\n        // NOTE we can only test this if NT exists\n        if (typeof window !== \"undefined\" &&\n            typeof window.performance !== \"undefined\" &&\n            typeof window.performance.timing !== \"undefined\" &&\n            window.performance.timing.navigationStart) {\n            proclaim.throws(function() {\n                perf.mark(\"navigationStart\");\n            });\n        }\n    });\n\n    // create a bunch of marks, then ensure all of the marks's times are\n    // greater than or equal to the last mark (i.e. in chronological order)\n    it(\"should mark timestamps that incremenet (or equal) each previous mark\", function() {\n        for (var i = 0; i < 100; i++) {\n            perf.mark(\"foo\");\n        }\n\n        // make sure we have the same amount of marks\n        var marks = perf.getEntriesByType(\"mark\");\n        proclaim.equal(marks.length, 100);\n\n        // ensure chronological order\n        var lastTime = 0;\n        for (i = 0; i < marks.length; i++) {\n            proclaim.greaterThan(marks[i].startTime, 0);\n            proclaim.ok(marks[i].startTime >= lastTime);\n            lastTime = marks[i].startTime;\n        }\n    });\n});\n\ndescribe(\"clearMarks()\", function() {\n    beforeEach(function() {\n        perf.clearMarks();\n        perf.clearMeasures();\n    });\n\n    it(\"should work for a single mark when called without arguments\", function() {\n        perf.mark(\"foo\");\n        proclaim.equal(perf.getEntriesByType(\"mark\").length, 1);\n\n        perf.clearMarks();\n        proclaim.equal(perf.getEntriesByType(\"mark\").length, 0);\n    });\n\n    it(\"should work OK before any marks are called\", function() {\n        proclaim.equal(perf.getEntriesByType(\"mark\").length, 0);\n        perf.clearMarks();\n        proclaim.equal(perf.getEntriesByType(\"mark\").length, 0);\n    });\n\n    it(\"should work OK if there are no marks of that name\", function() {\n        perf.mark(\"1\");\n        proclaim.equal(perf.getEntriesByType(\"mark\").length, 1);\n        perf.clearMarks(\"2\");\n        proclaim.equal(perf.getEntriesByType(\"mark\").length, 1);\n    });\n\n    it(\"should clear marks of a specified name\", function() {\n        perf.mark(\"foo1\");\n        perf.mark(\"foo2\");\n        proclaim.equal(perf.getEntriesByType(\"mark\").length, 2);\n\n        // clear, shouldn't have removed foo2\n        perf.clearMarks(\"foo1\");\n        proclaim.equal(perf.getEntriesByType(\"mark\").length, 1);\n\n        perf.clearMarks(\"foo2\");\n\n        // foo2 should now be removed\n        proclaim.equal(perf.getEntriesByType(\"mark\").length, 0);\n    });\n\n    it(\"should only remove marks, not measures\", function() {\n        perf.mark(\"foo\");\n        proclaim.equal(perf.getEntriesByType(\"mark\").length, 1);\n\n        // measure something\n        perf.measure(\"foo\");\n        perf.measure(\"foo\");\n\n        // clear\n        perf.clearMarks();\n        proclaim.equal(perf.getEntriesByType(\"mark\").length, 0);\n        proclaim.equal(perf.getEntriesByType(\"measure\").length, 2);\n\n    });\n});\n\ndescribe(\"PerformanceTimeline\", function() {\n    beforeEach(function() {\n        perf.clearMarks();\n        perf.clearMeasures();\n    });\n\n    describe(\"getEntries()\", function() {\n        it(\"should work when called without arguments and nothing had been called before it\", function() {\n            var entries = perf.getEntries();\n\n            // can't guarantee there aren't other entries from the PT if the PT is natively supported\n            proclaim.ok(entries.length >= 0);\n        });\n\n        it(\"should work when called without arguments and at least one mark had been logged\", function() {\n            perf.mark(\"1\");\n\n            var entries = perf.getEntries();\n\n            // can't guarantee there aren't other entries from the PT if the PT is natively supported\n            proclaim.greaterThan(entries.length, 0);\n        });\n\n        it(\"should sort entries\", function() {\n            // measures can be inserted out of order, because they're sorted by startTime which can be\n            // specified as part of the measure\n            perf.mark(\"1\");\n\n            // startTime will be \"now\", i.e. non-0\n            perf.measure(\"1\", \"1\");\n\n            // measure from navStart, which will be startTime=0\n            perf.measure(\"0\");\n\n            var entries = perf.getEntriesByType(\"measure\");\n            proclaim.isInstanceOf(entries, Array);\n            proclaim.equal(entries[0].startTime, 0);\n            proclaim.equal(entries[0].name, \"0\");\n            proclaim.equal(entries[1].name, \"1\");\n        });\n    });\n\n    describe(\"getEntriesByType()\", function() {\n        it(\"should work when nothing has been logged\", function() {\n            var entries = perf.getEntriesByType(\"mark\");\n            proclaim.equal(entries.length, 0);\n        });\n\n        it(\"should work with marks\", function() {\n            perf.mark(\"mark1\");\n            perf.measure(\"measure1\");\n\n            var entries = perf.getEntriesByType(\"mark\");\n            proclaim.equal(entries.length, 1);\n            proclaim.equal(entries[0].name, \"mark1\");\n            proclaim.greaterThan(entries[0].startTime, 0);\n        });\n\n        it(\"should work with marks when none had been logged\", function() {\n            perf.measure(\"measure1\");\n\n            var entries = perf.getEntriesByType(\"mark\");\n            proclaim.equal(entries.length, 0);\n        });\n\n        it(\"should work with measures\", function() {\n            perf.mark(\"mark1\");\n            perf.measure(\"measure1\");\n\n            var entries = perf.getEntriesByType(\"measure\");\n            proclaim.equal(entries.length, 1);\n            proclaim.equal(entries[0].name, \"measure1\");\n            proclaim.ok(entries[0].startTime >= 0);\n        });\n\n        it(\"should work with measures when none had been logged\", function() {\n            perf.mark(\"mark1\");\n\n            var entries = perf.getEntriesByType(\"measure\");\n            proclaim.equal(entries.length, 0);\n        });\n\n        it(\"should return an empty array if given a bad type\", function() {\n            // ensure the source array wasn\"t modified\n            var entries = perf.getEntriesByType(\"BAD_TYPE!!!\");\n            proclaim.isInstanceOf(entries, Array);\n            proclaim.equal(entries.length, 0);\n        });\n    });\n\n    describe(\"getEntriesByName()\", function() {\n        it(\"should work when nothing has been logged\", function() {\n            var entries = perf.getEntriesByName(\"mark\");\n            proclaim.equal(entries.length, 0);\n        });\n\n        it(\"should work when a mark and measure share the same name\", function() {\n            perf.mark(\"1\");\n            perf.measure(\"1\");\n\n            var entries = perf.getEntriesByName(\"1\");\n            proclaim.equal(entries.length, 2);\n            proclaim.equal(entries[0].name, \"1\");\n            proclaim.equal(entries[1].name, \"1\");\n        });\n    });\n});\n\ndescribe(\"now()\", function() {\n    it(\"should return a number greater than zero\", function() {\n        proclaim.greaterThan(perf.now(), 0);\n    });\n\n    it(\"should return sequential numbers\", function() {\n        var time1 = perf.now();\n        var time2 = perf.now();\n        proclaim.ok(time2 >= time1);\n    });\n\n    it(\"should be offset by navigationStart, not in Unix epoch format\", function() {\n        // now() shouldn\"t be over 1000000000000, because the test would be running for >40 years\n        // to get to that point\n        proclaim.lessThan(perf.now(), 1000000000000);\n    });\n});\n\ndescribe(\"measure()\", function() {\n    beforeEach(function() {\n        perf.clearMarks();\n        perf.clearMeasures();\n    });\n\n    it(\"should work even when there are no existing marks\", function() {\n        perf.measure(\"foo\");\n\n        var entries = perf.getEntriesByType(\"measure\");\n\n        proclaim.equal(entries.length, 1);\n        proclaim.equal(entries[0].name, \"foo\");\n        proclaim.equal(entries[0].startTime, 0);\n    });\n\n    it(\"should work when given a start mark as an argument\", function() {\n        perf.mark(\"1\");\n\n        perf.measure(\"1\", \"1\");\n\n        var entries = perf.getEntriesByType(\"measure\");\n\n        proclaim.equal(entries.length, 1);\n        proclaim.equal(entries[0].name, \"1\");\n        proclaim.greaterThan(entries[0].startTime, \"0\");\n        proclaim.ok(entries[0].duration >= 0);\n    });\n\n    it(\"should work when given a start and end mark\", function() {\n        perf.mark(\"1\");\n        perf.mark(\"2\");\n\n        perf.measure(\"1\", \"1\", \"2\");\n\n        var entries = perf.getEntriesByType(\"measure\");\n\n        proclaim.equal(entries.length, 1);\n        proclaim.equal(entries[0].name, \"1\");\n        proclaim.greaterThan(entries[0].startTime, \"0\");\n        proclaim.ok(entries[0].duration >= 0);\n\n        // likely didn\"t take 10 seconds\n        proclaim.ok(entries[0].duration < 10000);\n    });\n\n    it(\"should throw an error if not given a name\", function() {\n        proclaim.throws(perf.measure);\n    });\n\n    it(\"should throw an error if not given a name\", function() {\n        proclaim.throws(perf.measure);\n    });\n\n    it(\"should throw an exception if the start mark name is not found\", function() {\n        proclaim.throws(function() {\n            perf.measure(\"foo\", \"BAD_MARK!\");\n        }, Error);\n    });\n\n    it(\"should throw an exception if the end mark name is not found\", function() {\n        perf.mark(\"1\");\n        proclaim.throws(function() {\n            perf.measure(\"foo\", \"1\", \"BAD_MARK!\");\n        }, Error);\n    });\n});\n\ndescribe(\"clearMeasures()\", function() {\n    beforeEach(function() {\n        perf.clearMarks();\n        perf.clearMeasures();\n    });\n\n    it(\"should work when no measures had already been logged\", function() {\n        proclaim.equal(perf.getEntriesByType(\"measure\").length, 0);\n        perf.clearMeasures();\n        proclaim.equal(0, perf.getEntriesByType(\"measure\").length, 0);\n    });\n\n    it(\"should work when a single measure had already been logged\", function() {\n        perf.measure(\"foo\");\n        proclaim.equal(perf.getEntriesByType(\"measure\").length, 1);\n\n        perf.clearMeasures();\n        proclaim.equal(0, perf.getEntriesByType(\"measure\").length, 0);\n    });\n\n    it(\"should clear measures of the specified name\", function() {\n        perf.measure(\"foo1\");\n        perf.measure(\"foo2\");\n        proclaim.equal(perf.getEntriesByType(\"measure\").length, 2);\n\n        // clear, shouldn\"t have removed foo2\n        perf.clearMeasures(\"foo1\");\n        proclaim.equal(perf.getEntriesByType(\"measure\").length, 1);\n\n        perf.clearMeasures(\"foo2\");\n\n        // foo2 should now be removed\n        proclaim.equal(perf.getEntriesByType(\"measure\").length, 0);\n    });\n\n    it(\"should work OK if there are no marks of that name\", function() {\n        perf.measure(\"foo1\");\n        proclaim.equal(perf.getEntriesByType(\"measure\").length, 1);\n        perf.clearMeasures(\"foo2\");\n        proclaim.equal(perf.getEntriesByType(\"measure\").length, 1);\n    });\n});"}