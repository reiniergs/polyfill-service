{"aliases":["es6","default-3.6","default"],"browsers":{"ie":"<12","safari":"<7.1","firefox":"<29","chrome":"<38","android":"<5.1","firefox_mob":"<29","ie_mob":"*","opera_mob":"*","ios_saf":"<7.1","bb":"10 - *"},"dependencies":["Array.prototype.indexOf","Symbol","Symbol.iterator","Symbol.species","Object.defineProperty","Number.isNaN"],"notes":["For compatibility with very old engines, `Set.prototype.delete` must be accessed using square bracket notation because 'delete' is a reserved word. `mySet.delete()` is an error in IE8. Use `mySet['delete']()` instead.","The test suite for this polyfill is derived from work of Andrea Giammarchi which is [published under an MIT licence](https://github.com/WebReflection/es6-collections)"],"detectSource":"'Set' in this && (function() {\n\treturn (new Set([1,2])).size === 2;\n}())","testSource":"","baseDir":"Set","hasTests":true,"testsSource":"/* eslint-env mocha, browser*/\n/* global proclaim, it */\n\nvar o, generic, callback;\n\nbeforeEach(function() {\n\tif ('Set' in window) o = new Set();\n\tgeneric = {};\n\tcallback = function () {};\n})\n\nit(\"has valid constructor\", function () {\n\tproclaim.isInstanceOf(new Set, Set);\n\tproclaim.isInstanceOf(new Set(), Set);\n\tif (\"__proto__\" in {}) {\n\t\tproclaim.equal((new Set).__proto__.isPrototypeOf(new Set()), true);\n\t\tproclaim.equal((new Set).__proto__ === Set.prototype, true);\n\t}\n});\n\nit (\"can be pre-populated\", function() {\n    var s = new Set([1,2]);\n\tproclaim.equal(s.has(1), true);\n\tproclaim.equal(s.has(2), true);\n\tproclaim.equal(s.has(3), false);\n\tproclaim.equal(s.size, 2);\n});\n\nit(\"implements .size()\", function () {\n\tproclaim.equal(o.size, 0);\n\to.add(\"a\");\n\tproclaim.equal(o.size, 1);\n\to[\"delete\"](\"a\"); // Use square-bracket syntax to avoid a reserved word in old browsers\n\tproclaim.equal(o.size, 0);\n});\n\nit(\"implements .has()\", function () {\n\tproclaim.equal(o.has(callback), false);\n\to.add(callback);\n\tproclaim.equal(o.has(callback), true);\n});\n\nit(\"implements .add()\", function () {\n\tproclaim.equal(o.add(NaN), o);\n\tproclaim.equal(o.has(NaN), true);\n});\n\nit(\"implements .delete()\", function () {\n\to.add(callback);\n\to.add(generic);\n\to.add(o);\n\tproclaim.equal(o.has(callback), true);\n\tproclaim.equal(o.has(generic), true);\n\tproclaim.equal(o.has(o), true);\n\to[\"delete\"](callback);\n\to[\"delete\"](generic);\n\to[\"delete\"](o);\n\tproclaim.equal(o.has(callback), false);\n\tproclaim.equal(o.has(generic), false);\n\tproclaim.equal(o.has(o), false);\n\tproclaim.equal(o[\"delete\"](o), false);\n\to.add(o);\n\tproclaim.equal(o[\"delete\"](o), true);\n});\n\nit(\"exhibits correct iterator behaviour\", function () {\n\t// test that things get returned in insertion order as per the specs\n\to = new Set([\"1\", \"2\", \"3\"]);\n\tvar values = o.values();\n\tvar v = values.next();\n\tproclaim.equal(v.value, \"1\");\n\to['delete'](\"2\");\n\tv = values.next();\n\tproclaim.equal(v.value, \"3\");\n\t// insertion of previously-removed item goes to the end\n\to.add(\"2\");\n\tv = values.next();\n\tproclaim.equal(v.value, \"2\");\n\t// when called again, new iterator starts from beginning\n\tvar entriesagain = o.entries();\n\tproclaim.equal(entriesagain.next().value[0], \"1\");\n\tproclaim.equal(entriesagain.next().value[0], \"3\");\n\tproclaim.equal(entriesagain.next().value[0], \"2\");\n\t// after a iterator is finished, don't return any more elements\n\tv = values.next();\n\tproclaim.equal(v.done, true);\n\tv = values.next();\n\tproclaim.equal(v.done, true);\n\to.add(\"4\");\n\tv = values.next();\n\t// new element shows up in iterators that didn't yet finish\n\tproclaim.equal(entriesagain.next().value[0], \"4\");\n\tproclaim.equal(entriesagain.next().done, true);\n\t// value is present but undefined when done is true, so that Array.from and other noncompliant\n\t// interfaces recognize it as a valid iterator\n\tvar lastResult = entriesagain.next();\n\tproclaim.equal(lastResult.done, true);\n\tproclaim.ok(lastResult.hasOwnProperty('value'));\n\tproclaim.equal(lastResult.value, void 0);\n});\n\nit(\"implements .forEach()\", function () {\n\tvar o = new Set(), i = 0;\n\to.add(\"val 0\");\n\to.add(\"val 1\");\n\to.forEach(function (value, sameValue, obj) {\n\t\tproclaim.equal(value, \"val \" + i++);\n\t\tproclaim.equal(value, sameValue);\n\t\tproclaim.equal(obj, o);\n\t\t// even if dropped, keeps looping\n\t\to[\"delete\"](value);\n\t});\n\tproclaim.equal(o.size, 0);\n});\n\nit(\"implements .entries()\", function () {\n\tvar o, entries, current;\n\t\n\t// Iterator is correct when first item is deleted\n\to = new Set([1, 2, 3]);\n\to[\"delete\"](1);\n\tentries = o.entries();\n\tcurrent = entries.next();\n\tproclaim.equal(false, current.done);\n\tproclaim.equal(2, current.value[0]);\n\tcurrent = entries.next();\n\tproclaim.equal(false, current.done);\n\tproclaim.equal(3, current.value[0]);\n\tcurrent = entries.next();\n\tproclaim.equal(true, current.done);\n\tproclaim.equal(\"undefined\", typeof current.value);\n\t\n\t// Iterator is correct when middle item is deleted\n\to = new Set([1, 2, 3]);\n\to[\"delete\"](2);\n\tentries = o.entries();\n\tcurrent = entries.next();\n\tproclaim.equal(false, current.done);\n\tproclaim.equal(1, current.value[0]);\n\tcurrent = entries.next();\n\tproclaim.equal(false, current.done);\n\tproclaim.equal(3, current.value[0]);\n\tcurrent = entries.next();\n\tproclaim.equal(true, current.done);\n\tproclaim.equal(\"undefined\", typeof current.value);\n\t\n\t// Iterator is correct when last item is deleted\n\to = new Set([1, 2, 3]);\n\to[\"delete\"](3);\n\tentries = o.entries();\n\tcurrent = entries.next();\n\tproclaim.equal(false, current.done);\n\tproclaim.equal(1, current.value[0]);\n\tcurrent = entries.next();\n\tproclaim.equal(false, current.done);\n\tproclaim.equal(2, current.value[0]);\n\tcurrent = entries.next();\n\tproclaim.equal(true, current.done);\n\tproclaim.equal(\"undefined\", typeof current.value);\n});\n\nit(\"supports mutations during forEach loops\", function () {\n\tvar o = new Set([\"0\",\"1\",\"2\"]), seen = [];\n\to.forEach(function (value, valueAgain, obj) {\n\t\tseen += ','+value;\n\t\tproclaim.equal(obj, o);\n\t\tproclaim.equal(value, valueAgain);\n\t\t// mutations work as expected\n\t\tif (value === \"1\") {\n\t\t\to['delete'](\"0\"); // remove from before current index\n\t\t\to['delete'](\"2\"); // remove from after current index\n\t\t\to.add(\"3\"); // insertion\n\t\t} else if (value === \"3\") {\n\t\t\to.add(\"0\"); // insertion at the end\n\t\t}\n\t});\n\tproclaim.equal(seen, \",0,1,3,0\");\n});\n\nit(\"implements .clear()\", function(){\n\tvar o = new Set();\n\to.add('1');\n\to.add('2');\n\to.add('3');\n\to.clear();\n\tproclaim.equal(o.size, 0);\n});"}